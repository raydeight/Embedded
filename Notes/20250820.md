### August 20, 2025
Code is 0_led_toggle_addr
Minutes = 100 minutes
Steps:
Download:
Reference Manual - info about all the registers and each bits/registers
Datasheet
User Manual

Each Port has pins

Memory Mapping, the parts we're interested in are the peripherals
    Peripheral Block starts from 0x4000 0000 to 0xE00F FFFF
Every peripheral / module needs access to the clock, and busses carry the clock to the various parts of the microcontroller 

APB - Advanced Peripheral Bus
AHP - Advanced High Performance Bus

Through AHP bus, we can acess a pheriphereal with less clock cycles. 
microcontrollers have direction register and data register
direction register is used to set the pin to either input or output
data register stores data, so if it's an input then the data received is going to be kept in the data register, if output then the data you want to output you pass it through the data register

// originally it's 0b 0000 0000 0000 0000 0000 0000 0000 0000
//  but 1U << 0 states, shift one at position 0
//thus turning to  0b 0000 0000 0000 0000 0000 0000 0000 0001
// lets say you have  GPIOAEN		(1U << 1)
// now that would mean you shift thus turning to position 1 0b 0000 0000 0000 0000 0000 0000 0000 0010

// lets say you have  GPIOAEN		(1U << 4)
// now that would mean you shift thus turning to position 4 0b 0000 0000 0000 0000 0000 0001 0000 0010


MODE Register to configure GPIO pin as an output pin
Then use output data register to store the data we want to write to a particular pin
modeR = mode register
GPIO port mode register (GPIOx_MODER) (x  can be A thru E and H)
address offset: 0x00 

To configure a single pin, you need to manipulate or toggle two bits you need to configure 2 bits to configure the mode of a single pin.

Since we're interested in pin A5, we are interested in MODER5 and MODER5 occupies bits 10 and bits 11

To get PA5 to set as output, need to look at truth table. 
00 - input 
01 general purpose output 
10- alternate function (it could be an rx or tx protocol) 
11- analog pin

Set 10 to bit 1 because the reset value of the uc has the bits already set to 0.
0xA800 0000 for port A, abd modeR5 is within the first 4 hex. since we need bits 10 and bits 11 

set bit 10 to 01 

//  ( 1U <<10 ) // set bit 10 to 1
// (1U << 11) // set bit 11 to 1

/*We are going to invert this 
 * &=~(1U<<11) // SETS BIT 11 TO 0

 Now setting the output data
 GPIO port output data register (GPIOx_ODR) (x can be A thru E and H)
 address offset is 0x14

OUTPUT DATA REGISTER = ODR
 ODR has 32 bits, reset value is 0x0000 00000
 we are interested to pin 5, so ODR5, so we would have to write 0 to pin 5


our registers have address
conversion to use the register properly and to access this, w
typcast to volatine int pointer and dereference the pointer "*(volatile unsigned int *)  "
AHB enable Register
GPIOA Register
OD Register

RCC ahb1 enable register example -  
initial content 0b 0000 0000 0000 0000 1000 1111 0000 0000

but if we say rcc_ahb1enr = 0b 0000 0000 0000 0000 0000 0000 0000 0001

you're replacing the initial content to the the new value, where everything except bit 0 is 1.
we do not want that

to combat this we can use the |= commaned
RCC_AHB1EN_R |= GPIOAEN; 
this now means
it goes from this
0b 0000 0000 0000 0000 1000 1111 0000 0000
to this
0b 0000 0000 0000 0000 1000 1111 0000 0001

keep everything the same except particular bit to 0, we use &=~

rcc_ahb1en_r
/* Author: John D.
 * Date: August 20, 2025
 * Description: Turn on the LED with a Push of Button
 *
 * Where is LED connected?
 * Port A
 * Pin: 5
 *
 *Bus -> Boundary Address -> Peripheral
 *
 *  */
// locating address for the peripherals we need
#define PERIPH_BASE ( 0x40000000UL) // unsigned length
#define AHB1_PERIPH_OFFSET  (0x00020000UL)
#define AHB1_PERIPH_BASE	(PERIPH_BASE + AHB1PERIPH_OFFSET)
// 0x4000 0000 + 0x0002 0000 // peripheral base address 0x4000 0000 is starting point, and 0x0002 0000 is the offset
#define GPIOA_OFFSET 	(0x0000UL) // 0x20000 is fine but 0x2000 is not
#define GPIOA_BASE (AHB1_PERIPH_BASE + GPIOA_OFFSET)

#define RCC_OFFSET (0x3800UL)
#define RCC_BASE (AHB1_PERIPH_BASE + RCC_OFFSET) // we need RCC to enable clock access GPIO A, we need pin 5 for GPIO A

// locate the addresses of the registers we need within the peripherals - go to reference manual
//RCC AHB1 peripheral clock enable register (RCC_AHB1ENR)
//addr offset: 0x3 FOR AHB1 Enable RCC Offset

#define AHB1EN_R_OFFSET (0x30UL) // enable R offset
#define RCC_AHB1EN_R    (RCC_BASE + AHB1EN_R_OFFSET)

//GPIOAEN : IO port A clock enable , 0 A disabled 1 A enabled
// set bit register of GPIOAEN to 1

#define GPIOAEN		(1U << 0) // SHIFT 1 TO position 1
